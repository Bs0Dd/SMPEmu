	; MK90 Genjitsu-based Cartridge Menu 2.0 [universal]
	; by Akasaka / Genjitsu Labs, 2018
	; and Bs0Dd [bs0dd.net], 2025

	.ENABL AMA ; Absolute addressing
	.ASECT ; Absolute section
	.= 0 ; Beginning of cartridge
	NOP ; Obligatory!

	LCDINA = 164000
	LCDINB = 164002
	SMPCMD = 164026
	SMPBAUD = 164022
	SMPCS = 164024
	SMPIO = 164020

	mov r5, -(sp)

	cmpb @#115252, #62 ; BASIC 2.0? (second vectors set)
	bne bas1
	mov #SPRATTRS, r1
	mov #PRINTATTRS, r5
	mov #11, r2
b2a:
	mov (r1)+, (r5)+
	sob r2, b2a

bas1:
	call @INITRAM ; OS initialisation
	mov #30000, @SCRPTR

	call @#SETCONST
	mov (sp)+, r5

	mov #27476, sp ; Move stack to nearly end of RAM

	mov r5, -(sp) ; Save current SMP slot number

	call @#LOADR ; Load full data


	; -------------------------------
	; 	I n i t i a l i s a t i o n
	; -------------------------------

	call @INITTTY ; Init "console"
	inc @DISCURS ; Disable cursor

	; LCD controller initialisation
	mov @SCRPTR, @#LCDINA
	mov #104306, @#LCDINB

	bis #41, @PRINTATTRS ; Black background

	jmp @#main ; Go to the main part

LOADR: ; SMP data loader
	mtps #340 ; Disable interrupts
	bis #10, r5 ; Writing to the SMP
	mov r5, (r1)
	mov #240, @#SMPCMD ; Write Address
	call (r2)
	mov #1, @#SMPIO ; High address byte (start from o774 to restore data smashed by the stack)
	call (r2)
	mov #374, @#SMPIO ; Low address byte
	call (r2)
	tst @#SMPCMD
	call (r2)
	; Load data
	mov #END-774, r4 ; Number of bytes
	mov #774, r3
	mov #320, @#SMPCMD ; Read Postincrement
	call (r2)
	bic #10, r5 ; Reading from the SMP
	mov r5, (r1)
	call (r2)
nxtb:
	movb @#SMPIO, (r3)+ ; Read data byte from the SMP to the RAM
	call (r2)
	sob r4, nxtb ; Next data byte
smpdone: ; Addition from issue #5 to fix keyboard, thanks Piotr
	tst @#SMPCMD
	call (r2)
	rts pc

; Addresses for BASIC 1.0 (used by default)
PRINTATTRS:
	.word 34072
PRINT:
	.word 153414
INITRAM:
	.word 153700
INITTTY:
	.word 120536
WAITCOMM:
	.word 174506
SCRPTR:
	.word 34022
DISCURS:
	.word 34076
CURSX:
	.word 34044
CURSY:
	.word 33726

; Addresses for BASIC 2.0
SPRATTRS:
	.word 6534
SPRINT:
	.word 160372
SINITRAM:
	.word 145154
SINITTTY:
	.word 122324
SWAITCOMM:
	.word 174546
SSCRPTR:
	.word 6402
SDISCURS:
	.word 6540
SCURSX:
	.word 6506
SCURSY:
	.word 6120

; ------------
.=310
	.word KEYINT, 0 ; Keyboard handler vector
; ------------


	; -------------------------------
	; 	Commands to control the EMU 
	; -------------------------------

EMULS: ; List the files on the EMU Cart
	call @#SETCONST
	; Select SMP address
	bis #10, r5 ; Writing to the SMP
	mov r5, (r1)
	mov #360, @#SMPCMD ; CMD: 0xF0 List Files In Card
	call (r2)
	bic #10, r5 ; CMD: reading from the SMP
	mov r5, (r1)
	call (r2)
	mov #varArray, r3
lsloop:
	movb @#SMPIO, (r3)
	call (r2)
	movb (r3)+, r4
	bne nonzero 
	inc @#TOTALF ; Terminator - one filename received!
nonzero:
	cmpb r4, #377 ; Check if last one 0xFF
	bhis smpdone ; and go out
	br lsloop ; Otherwhise go on

EMUSEL: ; Set the emulated file name - zero terminated in r3
	call @#SETCONST
	mov 2(sp), r5 ; Restore SMP number from the first stack item
	bis #10, r5 ; Writing to the SMP
	mov r5, (r1)
	mov #361, @#SMPCMD ; CMD: 0xF1 Select File Name
	call (r2)
	; Write everything at r3 until 0x00 (inclusing 0x00)
selloop:
	movb (r3), @#SMPIO
	call (r2)
	tstb (r3)
	beq smpdone
	inc r3
	br selloop


	; ---------------------------
	; 	P r o c e d u r e s 
	; ---------------------------

KEYINT: ; Keyboard interrupt service routine
	call @#SETCONST
	mov #362, (r1)
	clr @#SMPCMD ; Start of the transfer
	call (r2)
	movb @#SMPCMD, r3 ; Key scan code, end of the transfer
	call (r2)
	mov #352, (r1)
	rti

BTOA: ; Byte to ASCII
	mov #3, r2
btc:
	clr r4
	div #12, r4
	add #60, r5
	movb r5, -(r1)
	mov r4, r5
	sob r2, btc
	rts pc

CLSTCL: ; Current list number to ASCII
	mov #TTBUF-1, r1
	movb @#LISTN, r5
	call @#BTOA
	mov #102, @CURSX
PAGPRT: ; For "Page" line print
	mov #70, @CURSY
	call @PRINT
	rts pc

SETCONST: ; Set constants
	mov #11, @#SMPBAUD ; CONST: transfer rate
	mov #SMPCS, r1 ; CONST: control/status register
	mov WAITCOMM, r2 ; CONST: procedure 'wait for the transfer completed'
	rts pc

SEEKNUM: ; Seek file name by the number
	mov #varArray, r1
	mov @#FILNUM, r3
SEEKALT:
	beq skend
skloop:
	tstb (r1)+
	bne skloop
	dec r3
	bne skloop
skend:
	rts pc

FILLST: ; Fill screen with 6 files (one page)
	mov #varArray, r1
	movb @#FILPOS, r2
	mov @#FILNUM, r3
	sub r2, r3
	inc r3
	call @#SEEKALT
	mov #6, r3
lstloop:
	movb (r1), r4
	cmpb  r4, #377
	bhis listend
	call @PRINT
	clr @CURSX ; CR
	add #10, @CURSY ; LF
	sob r3, lstloop
listend:
	rts pc

NEWSCR: ; Draw new files page
	mov @CURSY, -(sp)
	call @#CLSTCL
	clr @CURSX
	mov #10, @CURSY
	call @#CLRSCR
	call @#FILLST
	mov (sp)+, @CURSY
	rts pc

MOVSEL: ; Move file selection cursor
	mov r3, -(sp)
	call @#SEEKNUM
	clr @CURSX
	movb @#FILPOS, r3
	mul #10, r3
	mov r3, @CURSY
	call @PRINT
	clr @CURSX
	cmp (sp)+, #73
	beq mvbk
	incb @#FILPOS
	inc @#FILNUM
SELINIT: ; Init cursor
	add #10, r3
	br slnew
mvbk:
	decb @#FILPOS
	dec @#FILNUM
	sub #10, r3
slnew:
	mov r3, @CURSY
PRIVERS: ; Print cursor (inversed file name)
	bis #41, @PRINTATTRS
	call @#SEEKNUM
	call @PRINT
	bic #41, @PRINTATTRS
	rts pc

CLRSCR: ; Clear files list from the screen
	mov @SCRPTR, r1
	add #360, r1
	mov #550, r2
c1loop: ; First half of the screen
	clrb (r1)+
	inc r1
	sob r2, c1loop
	mov @SCRPTR, r1
	inc r1
	mov #550, r2
c2loop: ; Second half of the screen
	clrb (r1)+
	inc r1
	sob r2, c2loop
	rts pc


	; ----------------------------
	; 	M  a  i  n
	; ----------------------------

main:
	; Print the Title

	clr @CURSX ; X=0
	clr @CURSY ; Y=0

	mov #cartTitle, r1
	call @PRINT

	bic #41, @PRINTATTRS ; Disable inversion
	
	mov #cartPage, r1
	call @#PAGPRT

	; Retrieve array of file names
	call @#EMULS
	clr r2
	mov @#TOTALF, r3
	div #6, r2 ; Total pages (1 page - 6 files)
	tst r3
	beq noncomp
	inc r2 ; Round if remainder is non-zero
noncomp:
	movb r2, @#LISTT
	movb r2, r5
	mov #END-1, r1
	call @#BTOA

	call @#NEWSCR

	clr @CURSX
	clr r3
	call @#SELINIT

INLOOP: ; Input handling loop
	mtps #0
	mov #342, @#SMPCS ; Enable interrupts from the keyboard
	wait
	mtps #340

	mov #FILNUM, r0
	mov #LISTN, r1
	mov #FILPOS, r2
	mov CURSY, r4
	mov #NEWSCR, r5
ipgu: ; Previous page
	cmpb r3, #133
	bne ipgd
	cmpb (r1), #1
	beq INLOOP
	decb (r1)
	sub #6, (r0)
	call (r5)
	br pggu
ipgd: ; Next page
	cmpb r3, #273
	bne inup
	cmpb (r1), @#LISTT
	beq INLOOP
	incb (r1)
	mov (r0), r1
	mov @#TOTALF, r3
	dec r3
	add #6, r1
	cmp r1, r3
	ble iddo
	sub r3, r1
	sub r1, (r2)
	mul #10, r1
	sub r1, (r4)
	mov r3, r1
iddo:
	mov r1, (r0)
	call (r5)
	br pggu
inup: ; Previous file
	cmpb r3, #73
	bne indown
	tst (r0)
	beq INLOOP
	cmpb (r2), #1
	beq pgup
	call @#MOVSEL
	br INLOOP
pgup:
	cmpb (r1), #1
	beq INLOOP
	decb (r1)
	movb #6, (r2)
	dec (r0)
	call (r5)
	mov #60, @CURSY
pggu:
	clr @CURSX
	call @#PRIVERS
	br INLOOP
indown: ; Next file
	cmpb r3, #77
	bne entr
	mov @#TOTALF, r3
	dec r3
	cmp (r0), r3
	beq INLOOP
	cmpb (r2), #6
	beq pgdn
	call @#MOVSEL
	br INLOOP
pgdn:
	cmpb (r1), @#LISTT
	beq INLOOP
	incb (r1)
	movb #1, (r2)
	inc (r0)
	call (r5)
	clr @CURSX
	clr r3
	call @#SELINIT
	br INLOOP
entr: ; Mount file
	cmpb r3, #373
	bne INLOOP
	call @#SEEKNUM
	mov r1, r3
	call @#EMUSEL
	mov #cartSel, r1
	bis #41, @PRINTATTRS
	clr @CURSX
	call @PRINT
	mov #177777, r0
waiting:
	sob r0, waiting
	jmp @#173000 ; Reboot!


	; ----------------------------
	; 	Variables / Strings
	; ----------------------------

TOTALF: ; Total files
	.word 0
FILNUM: ; File number
	.word 0
FILPOS: ; File position
	.byte 1
LISTN: ; List number
	.byte 1
LISTT: ; Total lists
	.byte 1

	.even ; Unused byte

cartTitle:
	.asciz \ Genji\<16>\smp mEN@\<17>\ v2.0 \
cartSel:
	.asciz <16>\   pRIMONTIROWAN!   \
cartPage:
	.asciz <16>\  sTRANICA\<17>
CLBUF: 
	.ascii \000/\
TTBUF:
	.asciz \000\

END:
	varArray = 32000
